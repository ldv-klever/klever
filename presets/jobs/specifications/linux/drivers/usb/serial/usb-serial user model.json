{
  "3.14": [
    {
      "fragments": [
        "drivers/usb/serial/usbserial.ko"
      ],
      "model": {
        "functions models": {
          "driver_register": {
            "reference": true,
            "actions": {
              "assign": {
                "comment": "Get callbacks to register bus type.",
                "statements": [
                  "%driver% = $ARG1;"
                ]
              },
              "fail": {
                "comment": "Registration failed.",
                "statements": [
                  "return ldv_undef_int_negative();"
                ]
              },
              "register": {
                "comment": "Register {} callbacks.",
                "parameters": [
                  "%driver%"
                ],
                "peers": [
                  "bus/bus_scenario_usb_serial_bus_type"
                ]
              },
              "success": {
                "comment": "Registration of bus_type callbacks has been finished successfully.",
                "statements": [
                  "return 0;"
                ]
              }
            },
            "category": "functions models",
            "comment": "Register bus_type callbacks.",
            "declarations": {},
            "identifier": "functions models/driver_register",
            "labels": {
              "driver": {
                "declaration": "struct driver *driver"
              }
            },
            "process": "<assign>.[register].<success> | <fail>"
          },
          "driver_unregister": {
            "reference": true,
            "actions": {
              "assign": {
                "comment": "Get bus type callbacks.",
                "statements": [
                  "%driver% = $ARG1;"
                ]
              },
              "deregister": {
                "broadcast": true,
                "comment": "Deregister bus type callbacks.",
                "parameters": [
                  "%driver%"
                ],
                "peers": [
                  "bus/bus_scenario_usb_serial_bus_type"
                ]
              }
            },
            "category": "functions models",
            "comment": "Deregister bus type callbacks.",
            "identifier": "functions models/driver_unregister",
            "labels": {
              "driver": {
                "declaration": "struct device_driver *drv"
              }
            },
            "process": "<assign>.[@deregister]"
          },
          "tty_unregister_driver": {
            "reference": true,
            "actions": {
              "assign": {
                "comment": "Get a tty driver structure.",
                "statements": [
                  "%tty_driver% = $ARG1;",
                  "%tty_operations% = %tty_driver%->ops;"
                ]
              },
              "failed": {
                "comment": "Failed to unregister TTY driver.",
                "statements": [
                  "return ldv_undef_int_negative();"
                ]
              },
              "success": {
                "comment": "Successfully unregistered TTY driver.",
                "statements": [
                  "return 0;"
                ]
              }
            },
            "category": "functions models",
            "comment": "Unregister a tty device. (Relevant to 'serial_ops')",
            "headers": [
              "linux/tty.h",
              "linux/tty_driver.h"
            ],
            "identifier": "functions models/tty_unregister_driver",
            "labels": {
              "tty_driver": {
                "declaration": "struct tty_driver *tty_driver"
              },
              "tty_operations": {
                "declaration": "struct tty_operations *tty_operations",
                "value": "ldv_emg_alias_serial_ops_2"
              }
            },
            "process": "<assign>.<success> | <failed>"
          },
          "tty_register_driver": {
            "reference": true,
            "actions": {
              "assign": {
                "comment": "Get a tty driver structure.",
                "statements": [
                  "%tty_driver% = $ARG1;",
                  "%tty_operations% = %tty_driver%->ops;"
                ]
              },
              "failed": {
                "comment": "Failed to register TTY driver.",
                "statements": [
                  "return ldv_undef_int_negative();"
                ]
              },
              "success": {
                "comment": "Successfully registered TTY driver.",
                "statements": [
                  "return 0;"
                ]
              }
            },
            "category": "functions models",
            "comment": "Register tty driver. (Relevant to 'serial_ops')",
            "declarations": {
              "drivers/usb/serial/usb-serial.c": {
                "serial_ops": "struct tty_operations *ldv_emg_alias_serial_ops_2 = & serial_ops;\n"
              },
              "environment model": {
                "serial_ops": "extern struct tty_operations *ldv_emg_alias_serial_ops_2;\n"
              }
            },
            "headers": [
              "linux/tty.h",
              "linux/tty_driver.h"
            ],
            "identifier": "functions models/tty_register_driver",
            "labels": {
              "tty_driver": {
                "declaration": "struct tty_driver *tty_driver"
              },
              "tty_operations": {
                "declaration": "struct tty_operations *tty_operations",
                "value": "ldv_emg_alias_serial_ops_2"
              }
            },
            "process": "<assign>.<success> | <failed>"
          }
        },
        "environment processes": {
          "bus/bus_scenario_usb_serial_bus_type": {
            "reference": true,
            "actions": {
              "match": {
                "comment": "Call match callback",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_wrapper_usb_serial_device_match(%device%, %device_driver%);\", \"type\": \"CALLBACK\", \"comment\": \"match\"} */",
                  "ldv_wrapper_usb_serial_device_match(%device%, %device_driver%);"
                ]
              },
              "show": {
                "comment": "Show callback",
                "trace relevant": true,
                "statements": [
                  "$ALLOC(%buf%);",
                  "/* LDV {\"call\": \"ldv_wrapper_new_id_show(%device_driver%, %buf%);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                  "ldv_wrapper_new_id_show(%device_driver%, %buf%);",
                  "$FREE(%buf%);"
                ]
              },
              "store": {
                "comment": "Store callback",
                "trace relevant": true,
                "statements": [
                  "$ALLOC(%buf%);",
                  "%count% = ldv_undef_int();",
                  "/* LDV {\"call\": \"ldv_wrapper_new_id_store(%device_driver%, %buf%, %count%);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                  "ldv_wrapper_new_id_store(%device_driver%, %buf%, %count%);",
                  "$FREE(%buf%);"
                ]
              },
              "alloc": {
                "comment": "Allocate memory.",
                "statements": [
                  "$ALLOC(%device%);"
                ]
              },
              "skip": {
                "comment": "Do nothing",
                "statements": []
              },
              "deregister": {
                "comment": "Finish {} callbacks invocations scenario.",
                "condition": [],
                "parameters": [
                  "%device_driver%"
                ],
                "peers": [
                  "functions models/driver_unregister"
                ]
              },
              "failed_probe": {
                "comment": "Probing failed.",
                "condition": [
                  "%probe_retval% != 0"
                ]
              },
              "manage_interface": {
                "comment": "Manage particular interface on a device.",
                "process": "<probe>.(<probe_success>.(<match> | <show> | <store> | <skip>).<release> | <failed_probe>).{manage_interface[1]} | (deregister)"
              },
              "probe": {
                "comment": "Probe device.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"%probe_retval% = ldv_wrapper_usb_serial_device_probe(%device%);\", \"type\": \"CALLBACK\", \"comment\": \"probe\"} */",
                  "%probe_retval% = ldv_wrapper_usb_serial_device_probe(%device%);",
                  "/* Callback post-call */",
                  "%probe_retval% = ldv_post_probe(%probe_retval%);"
                ]
              },
              "probe_success": {
                "comment": "Check that interface has been probed successfully.",
                "condition": [
                  "%probe_retval% == 0"
                ]
              },
              "register": {
                "comment": "Begin USB callbacks invocation scenario.",
                "condition": [],
                "parameters": [
                  "%device_driver%"
                ],
                "peers": [
                  "functions models/driver_register"
                ],
                "replicative": true
              },
              "release": {
                "comment": "Remove device.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_wrapper_usb_serial_device_remove(%device%);\", \"type\": \"CALLBACK\", \"comment\": \"release\"} */",
                  "ldv_wrapper_usb_serial_device_remove(%device%);"
                ]
              }
            },
            "category": "bus",
            "comment": "Invoke usb serial bus type callbacks. (Relevant to 'usb_serial_bus_type')",
            "declarations": {
              "environment model": {
                "& usb_serial_device_match": "extern int ldv_wrapper_usb_serial_device_match(struct device *dev, struct device_driver *drv);\n",
                "& usb_serial_device_probe": "extern int ldv_wrapper_usb_serial_device_probe(struct device *dev);\n",
                "& usb_serial_device_remove": "extern int ldv_wrapper_usb_serial_device_remove(struct device *dev);\n",
                "& new_id_store": "extern ssize_t ldv_wrapper_new_id_store(struct device_driver *driver, const char *buf, size_t count);\n",
                "& new_id_show": "extern ssize_t ldv_wrapper_new_id_show(struct device_driver *driver, char *buf);\n"
              }
            },
            "definitions": {
              "drivers/usb/serial/bus.c": {
                "usb_serial_device_match": [
                  "/* AUX_FUNC ldv_wrapper_usb_serial_device_match */\n",
                  "int ldv_wrapper_usb_serial_device_match(struct device *dev, struct device_driver *drv) {\n",
                  "\t usb_serial_device_match(dev, drv);\n",
                  "}\n",
                  "\n"
                ],
                "usb_serial_device_probe": [
                  "/* AUX_FUNC ldv_wrapper_usb_serial_device_probe */\n",
                  "int ldv_wrapper_usb_serial_device_probe(struct device *dev) {\n",
                  "\treturn usb_serial_device_probe(dev);\n",
                  "}\n",
                  "\n"
                ],
                "usb_serial_device_remove": [
                  "/* AUX_FUNC ldv_wrapper_usb_serial_device_remove */\n",
                  "int ldv_wrapper_usb_serial_device_remove(struct device *dev) {\n",
                  "\treturn usb_serial_device_remove(dev);\n",
                  "}\n",
                  "\n"
                ],
                "new_id_store": [
                  "/* AUX_FUNC ldv_wrapper_new_id_store */\n",
                  "ssize_t ldv_wrapper_new_id_store(struct device_driver *driver, const char *buf, size_t count) {\n",
                  "\treturn new_id_store(driver, buf, count);\n",
                  "}\n",
                  "\n"
                ],
                "new_id_show": [
                  "/* AUX_FUNC ldv_wrapper_new_id_show */\n",
                  "ssize_t ldv_wrapper_new_id_show(struct device_driver *driver, char *buf) {\n",
                  "\treturn new_id_show(driver, buf);\n",
                  "}\n",
                  "\n"
                ]
              }
            },
            "headers": [
              "linux/device.h"
            ],
            "identifier": "bus/bus_scenario/usb_serial_bus_type",
            "labels": {
              "probe_retval": {
                "declaration": "int probe_retval",
                "value": "ldv_undef_int()"
              },
              "device": {
                "declaration": "struct device *dev"
              },
              "device_driver": {
                "declaration": "struct device_driver *drv"
              },
              "buf": {
                "declaration": "char *buf"
              },
              "count": {
                "declaration": "size_t count"
              }
            },
            "process": "(!register).<alloc>.{manage_interface}"
          },
          "usb_serial/tty_layer_usb_serial_generic_device": {
            "reference": true,
            "actions": {
              "deregister_tty_layer": {
                "comment": "End up with USB serial tty layer callbacks invocation scenario.",
                "condition": [
                  "%driver% == $ARG1",
                  "$ARG1 == & emg_alias_usb_serial_generic_device"
                ],
                "parameters": [
                  "%driver%"
                ],
                "peers": [
                  "usb_serial/usb_serial_scenario_usb_serial_generic_device"
                ]
              },
              "irq_write_4": {
                "comment": "Write a block of characters to the tty device in atomic context. Invoke callback irq_write from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "if (%driver%->write) {",
                  "\t/* Callback pre-call */",
                  "\tldv_switch_to_interrupt_context();",
                  "\t/* LDV {\"call\": \"%driver%->write(%resource_1%, %ldv_param_1_2%, %ldv_param_2_3%, %ldv_param_3_4%);\", \"type\": \"CALLBACK\", \"comment\": \"irq_write\"} */",
                  "\t%driver%->write(%resource_1%, %ldv_param_1_2%, %ldv_param_2_3%, %ldv_param_3_4%);",
                  "\t/* Callback post-call */",
                  "\tldv_switch_to_process_context();",
                  "}"
                ]
              },
              "post_call_11": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_8%);"
                ]
              },
              "post_call_14": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_9%);"
                ]
              },
              "post_call_17": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_0_10%);",
                  "$FREE(%ldv_param_2_11%);"
                ]
              },
              "post_call_21": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_12%);"
                ]
              },
              "post_call_25": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_0_13%);"
                ]
              },
              "post_call_28": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_0_14%);"
                ]
              },
              "post_call_3": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_3_4%);",
                  "$FREE(%ldv_param_2_3%);",
                  "$FREE(%ldv_param_1_2%);"
                ]
              },
              "post_call_6": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_2_6%);",
                  "$FREE(%ldv_param_1_5%);",
                  "$FREE(%ldv_param_3_7%);"
                ]
              },
              "pre_call_10": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_8%);"
                ]
              },
              "pre_call_13": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_9%);"
                ]
              },
              "pre_call_16": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_0_10%);",
                  "$UALLOC(%ldv_param_2_11%);"
                ]
              },
              "pre_call_2": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_3_4%);",
                  "$UALLOC(%ldv_param_2_3%);",
                  "$UALLOC(%ldv_param_1_2%);"
                ]
              },
              "pre_call_20": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_12%);"
                ]
              },
              "pre_call_24": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_0_13%);"
                ]
              },
              "pre_call_27": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_0_14%);"
                ]
              },
              "pre_call_5": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_2_6%);",
                  "$UALLOC(%ldv_param_1_5%);",
                  "$UALLOC(%ldv_param_3_7%);"
                ]
              },
              "register_tty_layer": {
                "comment": "Begin USB serial tty layer callbacks invocation scenario.",
                "condition": [
                  "$ARG1 == &emg_alias_usb_serial_generic_device"
                ],
                "parameters": [
                  "%driver%",
                  "%port%",
                  "%resource_1%"
                ],
                "peers": [
                  "usb_serial/usb_serial_scenario_usb_serial_generic_device"
                ],
                "replicative": true
              },
              "rest_line_attached_callbacks_12": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_tiocmiwait(%resource_1%, %ldv_param_1_8%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_tiocmiwait(%resource_1%, %ldv_param_1_8%);"
                ]
              },
              "rest_line_attached_callbacks_15": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_get_icount(%resource_1%, %ldv_param_1_9%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_get_icount(%resource_1%, %ldv_param_1_9%);"
                ]
              },
              "rest_line_attached_callbacks_18": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_prepare_write_buffer(%ldv_param_0_10%, %resource_0%, %ldv_param_2_11%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_prepare_write_buffer(%ldv_param_0_10%, %resource_0%, %ldv_param_2_11%);"
                ]
              },
              "rest_line_attached_callbacks_19": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_chars_in_buffer(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_chars_in_buffer(%resource_1%);"
                ]
              },
              "rest_line_attached_callbacks_22": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_wait_until_sent(%resource_1%, %ldv_param_1_12%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_wait_until_sent(%resource_1%, %ldv_param_1_12%);"
                ]
              },
              "rest_line_attached_callbacks_23": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_write_room(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_write_room(%resource_1%);"
                ]
              },
              "rest_line_attached_callbacks_26": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_read_bulk_callback(%ldv_param_0_13%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_read_bulk_callback(%ldv_param_0_13%);"
                ]
              },
              "rest_line_attached_callbacks_29": {
                "comment": "Invoke callback rest_line_attached_callbacks from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_write_bulk_callback(%ldv_param_0_14%);\", \"type\": \"CALLBACK\", \"comment\": \"rest_line_attached_callbacks\"} */",
                  "usb_serial_generic_write_bulk_callback(%ldv_param_0_14%);"
                ]
              },
              "throttle_8": {
                "comment": "Notify the tty driver that input buffers for the line discipline are close to full. Invoke callback throttle from usb_serial_driver.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_throttle(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"throttle\"} */",
                  "usb_serial_generic_throttle(%resource_1%);"
                ]
              },
              "tty_layer": {
                "comment": "Call the rest callbacks from tty layer.",
                "process": "(<throttle_8>.<unthrottle_9> | <carrier_raised> | <dtr> | <pre_call_2>.<irq_write_4>.<post_call_3> | <pre_call_5>.<write_7>.<post_call_6> | <pre_call_10>.(((((((<rest_line_attached_callbacks_12> | <pre_call_27>.<rest_line_attached_callbacks_29>.<post_call_28>) | <pre_call_24>.<rest_line_attached_callbacks_26>.<post_call_25>) | <rest_line_attached_callbacks_23>) | <pre_call_20>.<rest_line_attached_callbacks_22>.<post_call_21>) | <rest_line_attached_callbacks_19>) | <pre_call_16>.<rest_line_attached_callbacks_18>.<post_call_17>) | <pre_call_13>.<rest_line_attached_callbacks_15>.<post_call_14>).<post_call_11>).{tty_layer[1]} | (deregister_tty_layer)"
              },
              "dtr": {
                "comment": ".",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_wrapper_serial_port_dtr_rts(& %port%->port, ldv_undef_int());\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                  "ldv_wrapper_serial_port_dtr_rts(& %port%->port, ldv_undef_int());"
                ]
              },
              "carrier_raised": {
                "comment": "Call serial_port_carrier_raised.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_wrapper_serial_port_carrier_raised(& %port%->port);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                  "ldv_wrapper_serial_port_carrier_raised(& %port%->port);"
                ]
              },
              "unthrottle_9": {
                "comment": "Notify the tty drivers that it should signals that characters can now be sent. Invoke callback unthrottle from usb_serial_driver.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_generic_unthrottle(%resource_1%);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                  "usb_serial_generic_unthrottle(%resource_1%);"
                ]
              },
              "write_7": {
                "comment": "Write a block of characters to the tty device in atomic context. Invoke callback write from USB_SERIAL.",
                "trace relevant": true,
                "statements": [
                  "if (%driver%->write) {",
                  "\t/* LDV {\"call\": \"%driver%->write(%resource_1%, %ldv_param_1_5%, %ldv_param_2_6%, %ldv_param_3_7%);\", \"type\": \"CALLBACK\", \"comment\": \"write\"} */",
                  "\t%driver%->write(%resource_1%, %ldv_param_1_5%, %ldv_param_2_6%, %ldv_param_3_7%);",
                  "}"
                ]
              }
            },
            "category": "usb_serial",
            "comment": "Invoke USB serial tty layer callbacks. (Relevant to 'usb_serial_generic_device')",
            "declarations": {
              "drivers/usb/serial/generic.c": {
                "emg_alias_usb_serial_generic_device": "struct usb_serial_driver *emg_alias_usb_serial_generic_device = & usb_serial_generic_device;\n"
              },
              "environment model": {
                "& usb_serial_generic_throttle": "extern void usb_serial_generic_throttle(struct tty_struct *tty);\n",
                "& usb_serial_generic_unthrottle": "extern void usb_serial_generic_unthrottle(struct tty_struct *tty);\n",
                "&usb_serial_generic_chars_in_buffer": "extern int usb_serial_generic_chars_in_buffer(struct tty_struct *tty);\n",
                "&usb_serial_generic_get_icount": "extern int usb_serial_generic_get_icount(struct tty_struct *tty, struct serial_icounter_struct *icount);\n",
                "&usb_serial_generic_prepare_write_buffer": "extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port, void *dest, size_t size);\n",
                "&usb_serial_generic_read_bulk_callback": "extern void usb_serial_generic_read_bulk_callback(struct urb *urb);\n",
                "&usb_serial_generic_tiocmiwait": "extern int usb_serial_generic_tiocmiwait(struct tty_struct *tty, long unsigned int arg);\n",
                "&usb_serial_generic_wait_until_sent": "extern void usb_serial_generic_wait_until_sent(struct tty_struct *tty, long int timeout);\n",
                "&usb_serial_generic_write_bulk_callback": "extern void usb_serial_generic_write_bulk_callback(struct urb *urb);\n",
                "&usb_serial_generic_write_room": "extern int usb_serial_generic_write_room(struct tty_struct *tty);\n",
                "emg_alias_usb_serial_generic_device": "extern struct usb_serial_driver *emg_alias_usb_serial_generic_device;\n",
                "& serial_port_carrier_raised": "extern int ldv_wrapper_serial_port_carrier_raised(struct tty_port *port);\n",
                "& serial_port_dtr_rts": "extern void ldv_wrapper_serial_port_dtr_rts(struct tty_port *port, int on);\n"
              }
            },
            "definitions": {
              "drivers/usb/serial/usb-serial.c": {
                "serial_port_carrier_raised": [
                  "/* AUX_FUNC ldv_wrapper_serial_port_carrier_raised */\n",
                  "int ldv_wrapper_serial_port_carrier_raised(struct tty_port *port) {\n",
                  "\t serial_port_carrier_raised(port);\n",
                  "}\n",
                  "\n"
                ],
                "serial_port_dtr_rts": [
                  "/* AUX_FUNC ldv_wrapper_serial_port_dtr_rts */\n",
                  "void ldv_wrapper_serial_port_dtr_rts(struct tty_port *port, int on) {\n",
                  "\t serial_port_dtr_rts(port, on);\n",
                  "}\n",
                  "\n"
                ],
                "device_del": [
                  "/* AUX_FUNC device_del */\n",
                  "void device_del(struct device *dev) {\n",
                  "\t usb_serial_port_release(dev);\n",
                  "}\n",
                  "\n"
                ]
              }
            },
            "headers": [
              "linux/tty.h"
            ],
            "identifier": "usb_serial/tty_layer/usb_serial_generic_device",
            "labels": {
              "driver": {
                "declaration": "struct usb_serial_driver *driver",
                "value": "& emg_alias_usb_serial_generic_device"
              },
              "ldv_param_0_10": {
                "declaration": "struct usb_serial_port *ldv_param_0_10"
              },
              "ldv_param_0_13": {
                "declaration": "struct urb *ldv_param_0_13"
              },
              "ldv_param_0_14": {
                "declaration": "struct urb *ldv_param_0_14"
              },
              "ldv_param_1_12": {
                "declaration": "long int ldv_param_1_12"
              },
              "ldv_param_1_2": {
                "declaration": "struct usb_serial_port *ldv_param_1_2"
              },
              "ldv_param_1_5": {
                "declaration": "struct usb_serial_port *ldv_param_1_5"
              },
              "ldv_param_1_8": {
                "declaration": "long unsigned int ldv_param_1_8"
              },
              "ldv_param_1_9": {
                "declaration": "struct serial_icounter_struct *ldv_param_1_9"
              },
              "ldv_param_2_11": {
                "declaration": "long unsigned int ldv_param_2_11"
              },
              "ldv_param_2_3": {
                "declaration": "unsigned char *ldv_param_2_3"
              },
              "ldv_param_2_6": {
                "declaration": "unsigned char *ldv_param_2_6"
              },
              "ldv_param_3_4": {
                "declaration": "int ldv_param_3_4"
              },
              "ldv_param_3_7": {
                "declaration": "int ldv_param_3_7"
              },
              "port": {
                "declaration": "struct usb_serial_port *port"
              },
              "resource_0": {
                "declaration": "struct usb_serial *resource_0"
              },
              "resource_1": {
                "declaration": "struct tty_struct *resource_1"
              }
            },
            "process": "(!register_tty_layer).{tty_layer}"
          },
          "tty/tty_scenario_serial_ops": {
            "reference": true,
            "actions": {
              "call": {
                "comment": "Call rest tty callbacks.",
                "process": "(((((((((((<callback_2> | <seq_ops> | <pre_call_27>.<callback_29>.<post_call_28>) | <pre_call_24>.<callback_26>.<post_call_25>) | <pre_call_21>.<callback_23>.<post_call_22>) | <pre_call_18>.<callback_20>.<post_call_19>) | <pre_call_15>.<callback_17>.<post_call_16>) | <callback_14>) | <pre_call_11>.<callback_13>.<post_call_12>) | <callback_10>) | <pre_call_7>.<callback_9>.<post_call_8>) | <callback_6>) | <pre_call_41>.<set_termios_43>.<post_call_42> | <throttle_47>.<unthrottle_48> | <start_49>.<stop_50> | <pre_call_44>.<set_termiox_46>.<post_call_45>).{call[1]} | <pre_call_36>.<close_38>.<post_call_37>.<shutdown_39>.<remove_34>.<cleanup_40>.{main[1]}"
              },
              "callback_10": {
                "comment": "Invoke callback write_room from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_write_room_6(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_write_room_6(%tty_struct%);"
                ]
              },
              "callback_13": {
                "comment": "Invoke callback activate from tty_port_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_port_activate_7(%ldv_param_0_4%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_port_activate_7(%ldv_param_0_4%, %tty_struct%);"
                ]
              },
              "callback_14": {
                "comment": "Invoke callback hangup from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_hangup_8(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_hangup_8(%tty_struct%);"
                ]
              },
              "callback_17": {
                "comment": "Invoke callback write from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_write_9(%tty_struct%, %ldv_param_1_5%, %ldv_param_2_6%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_write_9(%tty_struct%, %ldv_param_1_5%, %ldv_param_2_6%);"
                ]
              },
              "callback_2": {
                "comment": "Invoke callback tiocmget from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_tiocmget_2(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_tiocmget_2(%tty_struct%);"
                ]
              },
              "callback_20": {
                "comment": "Invoke callback tiocmset from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_tiocmset_10(%tty_struct%, %ldv_param_1_7%, %ldv_param_2_8%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_tiocmset_10(%tty_struct%, %ldv_param_1_7%, %ldv_param_2_8%);"
                ]
              },
              "callback_23": {
                "comment": "Invoke callback wait_until_sent from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_wait_until_sent_11(%tty_struct%, %ldv_param_1_9%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_wait_until_sent_11(%tty_struct%, %ldv_param_1_9%);"
                ]
              },
              "callback_26": {
                "comment": "Invoke callback shutdown from tty_port_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_port_shutdown_12(%ldv_param_0_10%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_port_shutdown_12(%ldv_param_0_10%);"
                ]
              },
              "callback_29": {
                "comment": "Invoke callback ioctl from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_ioctl_13(%tty_struct%, %ldv_param_1_11%, %ldv_param_2_12%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_ioctl_13(%tty_struct%, %ldv_param_1_11%, %ldv_param_2_12%);"
                ]
              },
              "callback_6": {
                "comment": "Invoke callback chars_in_buffer from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_chars_in_buffer_4(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_chars_in_buffer_4(%tty_struct%);"
                ]
              },
              "callback_9": {
                "comment": "Invoke callback get_icount from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_get_icount_5(%tty_struct%, %ldv_param_1_3%);\", \"type\": \"CALLBACK\", \"comment\": \"callback\"} */",
                  "ldv_emg_wrapper_serial_get_icount_5(%tty_struct%, %ldv_param_1_3%);"
                ]
              },
              "cleanup_40": {
                "comment": "Free resources after a tty device has been closed for the last time. Invoke callback cleanup from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_cleanup_17(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"cleanup\"} */",
                  "ldv_emg_wrapper_serial_cleanup_17(%tty_struct%);"
                ]
              },
              "close_38": {
                "comment": "Close a tty device. Invoke callback close from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_close_16(%tty_struct%, %ldv_param_1_15%);\", \"type\": \"CALLBACK\", \"comment\": \"close\"} */",
                  "ldv_emg_wrapper_serial_close_16(%tty_struct%, %ldv_param_1_15%);"
                ]
              },
              "tty_deregister": {
                "comment": "Finish {} callbacks invocations scenario.",
                "peers": [
                  "usb/usb_scenario_usb_serial_driver"
                ]
              },
              "free": {
                "comment": "Free memory of file structure.",
                "statements": [
                  "$FREE(%file%);"
                ]
              },
              "init": {
                "comment": "Allocate memory for file structure.",
                "statements": [
                  "$ALLOC(%file%);"
                ]
              },
              "install_33": {
                "comment": "Install a new tty into the tty driver internal tables. Invoke callback install from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"%ret% = ldv_emg_wrapper_serial_install_14(%tty_driver%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"install\"} */",
                  "%ret% = ldv_emg_wrapper_serial_install_14(%tty_driver%, %tty_struct%);",
                  "/* Callback post-call */",
                  "%ret% = ldv_filter_err_code(%ret%);"
                ]
              },
              "install_failed": {
                "comment": "Failed to install a new tty into the tty driver internal tables.",
                "condition": [
                  "%ret% != 0"
                ]
              },
              "install_success": {
                "comment": "Successfully installed a new tty into the tty driver internal tables.",
                "condition": [
                  "%ret% == 0"
                ]
              },
              "lookup_32": {
                "comment": "Return the tty device corresponding to idx. Invoke callback lookup from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->lookup) {",
                  "\t/* Callback pre-call */",
                  "\t/* Expect that tty_mutex is locked */",
                  "\t/* LDV {\"call\": \"%tty_struct% = %tty_operations%->lookup(%tty_driver%, %ldv_param_1_13%, %ldv_param_2_14%);\", \"type\": \"CALLBACK\", \"comment\": \"lookup\"} */",
                  "\t%tty_struct% = %tty_operations%->lookup(%tty_driver%, %ldv_param_1_13%, %ldv_param_2_14%);",
                  "} else {",
                  "\t%tty_struct% = ldv_undef_ptr();",
                  "}"
                ]
              },
              "main": {
                "comment": "Install tty or deregister.",
                "process": "<pre_call_30>.<lookup_32>.<post_call_31>.<install_33>.(<install_success>.<open_35>.(<open_success>.{call} | <open_failed>.<remove_35>) | <install_failed>).{main[1]} | <free>.(tty_deregister)"
              },
              "open_35": {
                "comment": "Open a tty device. Invoke callback open from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"%ret% = ldv_emg_wrapper_serial_open_15(%tty_struct%, %file%);\", \"type\": \"CALLBACK\", \"comment\": \"open\"} */",
                  "%ret% = ldv_emg_wrapper_serial_open_15(%tty_struct%, %file%);",
                  "/* Callback post-call */",
                  "%ret% = ldv_filter_err_code(%ret%);"
                ]
              },
              "open_failed": {
                "comment": "Failed to open a particular tty device.",
                "condition": [
                  "%ret% != 0"
                ]
              },
              "open_success": {
                "comment": "Successfully opened a particular tty device.",
                "condition": [
                  "%ret% == 0"
                ]
              },
              "post_call_12": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_0_4%);"
                ]
              },
              "post_call_16": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_2_6%);",
                  "$FREE(%ldv_param_1_5%);"
                ]
              },
              "post_call_19": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_2_8%);",
                  "$FREE(%ldv_param_1_7%);"
                ]
              },
              "post_call_22": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_9%);"
                ]
              },
              "post_call_25": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_0_10%);"
                ]
              },
              "post_call_28": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_11%);",
                  "$FREE(%ldv_param_2_12%);"
                ]
              },
              "post_call_31": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_13%);",
                  "$FREE(%ldv_param_2_14%);"
                ]
              },
              "post_call_37": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_15%);"
                ]
              },
              "post_call_42": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_16%);"
                ]
              },
              "post_call_45": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_17%);"
                ]
              },
              "post_call_8": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_3%);"
                ]
              },
              "pre_call_11": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_0_4%);"
                ]
              },
              "pre_call_15": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_2_6%);",
                  "$UALLOC(%ldv_param_1_5%);"
                ]
              },
              "pre_call_18": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_2_8%);",
                  "$UALLOC(%ldv_param_1_7%);"
                ]
              },
              "pre_call_21": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_9%);"
                ]
              },
              "pre_call_24": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_0_10%);"
                ]
              },
              "pre_call_27": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_11%);",
                  "$UALLOC(%ldv_param_2_12%);"
                ]
              },
              "pre_call_30": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_13%);",
                  "$UALLOC(%ldv_param_2_14%);"
                ]
              },
              "pre_call_36": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_15%);"
                ]
              },
              "pre_call_41": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_16%);"
                ]
              },
              "pre_call_44": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_17%);"
                ]
              },
              "pre_call_7": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_3%);"
                ]
              },
              "tty_register": {
                "comment": "Begin {} callbacks invocations scenario.",
                "peers": [
                  "usb/usb_scenario_usb_serial_driver"
                ],
                "replicative": true
              },
              "remove_34": {
                "comment": "Remove a closed tty from the tty driver internal tables. Invoke callback remove from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->remove) {",
                  "\t/* LDV {\"call\": \"%tty_operations%->remove(%tty_driver%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"remove\"} */",
                  "\t%tty_operations%->remove(%tty_driver%, %tty_struct%);",
                  "}"
                ]
              },
              "remove_35": {
                "comment": "Remove a closed tty from the tty driver internal tables. Invoke callback remove from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->remove) {",
                  "\t/* LDV {\"call\": \"%tty_operations%->remove(%tty_driver%, %tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"remove\"} */",
                  "\t%tty_operations%->remove(%tty_driver%, %tty_struct%);",
                  "}"
                ]
              },
              "set_termios_43": {
                "comment": "Device's termios settings have changed. Invoke callback set_termios from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* Callback pre-call */",
                  "/* Expect that termios mutex is locked */",
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_set_termios_18(%tty_struct%, %ldv_param_1_16%);\", \"type\": \"CALLBACK\", \"comment\": \"set_termios\"} */",
                  "ldv_emg_wrapper_serial_set_termios_18(%tty_struct%, %ldv_param_1_16%);"
                ]
              },
              "set_termiox_46": {
                "comment": "The device receives a termiox based ioctl. Invoke callback set_termiox from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->set_termiox) {",
                  "\t/* Callback pre-call */",
                  "\t/* Expect that termios mutex is locked */",
                  "\t/* LDV {\"call\": \"%tty_operations%->set_termiox(%tty_struct%, %ldv_param_1_17%);\", \"type\": \"CALLBACK\", \"comment\": \"set_termiox\"} */",
                  "\t%tty_operations%->set_termiox(%tty_struct%, %ldv_param_1_17%);",
                  "}"
                ]
              },
              "shutdown_39": {
                "comment": "Close a tty device for the last time. Invoke callback shutdown from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->shutdown) {",
                  "\t/* Callback pre-call */",
                  "\t/* Expect that tty_mutex is locked */",
                  "\t/* LDV {\"call\": \"%tty_operations%->shutdown(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"shutdown\"} */",
                  "\t%tty_operations%->shutdown(%tty_struct%);",
                  "}"
                ]
              },
              "start_49": {
                "comment": "Resume sending characters to tty device. Invoke callback start from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->start) {",
                  "\t/* LDV {\"call\": \"%tty_operations%->start(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"start\"} */",
                  "\t%tty_operations%->start(%tty_struct%);",
                  "}"
                ]
              },
              "stop_50": {
                "comment": "Stop outputting characters to the tty device Invoke callback stop from TTY.",
                "trace relevant": true,
                "statements": [
                  "if (%tty_operations%->stop) {",
                  "\t/* LDV {\"call\": \"%tty_operations%->stop(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"stop\"} */",
                  "\t%tty_operations%->stop(%tty_struct%);",
                  "}"
                ]
              },
              "throttle_47": {
                "comment": "Input buffers for the line discipline are close to full. Invoke callback throttle from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* Callback pre-call */",
                  "/* Expect that termios mutex is locked */",
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_throttle_19(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"throttle\"} */",
                  "ldv_emg_wrapper_serial_throttle_19(%tty_struct%);"
                ]
              },
              "unthrottle_48": {
                "comment": "Characters can now be sent to the tty without fear of overrunning the input buffers of the line disciplines. Invoke callback unthrottle from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* Callback pre-call */",
                  "/* Expect that termios mutex is locked */",
                  "/* LDV {\"call\": \"ldv_emg_wrapper_serial_unthrottle_20(%tty_struct%);\", \"type\": \"CALLBACK\", \"comment\": \"unthrottle\"} */",
                  "ldv_emg_wrapper_serial_unthrottle_20(%tty_struct%);"
                ]
              },
              "seq_ops": {
                "comment": "Characters can now be sent to the tty without fear of overrunning the input buffers of the line disciplines. Invoke callback unthrottle from tty_operations.",
                "trace relevant": true,
                "statements": [
                  "/* Callback pre-call */",
                  "$UALLOC(%inode%);",
                  "/* LDV {\"call\": \"ldv_wrapper_serial_proc_open(%inode%, %file%);\", \"type\": \"CALLBACK\", \"comment\": \"proce_open\"} */",
                  "ldv_wrapper_serial_proc_open(%inode%, %file%);",
                  "/* LDV {\"call\": \"ldv_wrapper_serial_proc_show(0, 0);\", \"type\": \"CALLBACK\", \"comment\": \"show\"} */",
                  "ldv_wrapper_serial_proc_show(0, 0);",
                  "/* Callback post-call */",
                  "$FREE(%inode%);"
                ]
              }
            },
            "category": "tty",
            "comment": "Invoke tty callbacks (Relevant to 'serial_ops')",
            "declarations": {
              "environment model": {
                "serial_break": "extern int ldv_emg_wrapper_serial_break_3(struct tty_struct *, int);\n",
                "serial_chars_in_buffer": "extern int ldv_emg_wrapper_serial_chars_in_buffer_4(struct tty_struct *);\n",
                "serial_cleanup": "extern void ldv_emg_wrapper_serial_cleanup_17(struct tty_struct *);\n",
                "serial_close": "extern void ldv_emg_wrapper_serial_close_16(struct tty_struct *, struct file *);\n",
                "serial_get_icount": "extern int ldv_emg_wrapper_serial_get_icount_5(struct tty_struct *, struct serial_icounter_struct *);\n",
                "serial_hangup": "extern void ldv_emg_wrapper_serial_hangup_8(struct tty_struct *);\n",
                "serial_install": "extern int ldv_emg_wrapper_serial_install_14(struct tty_driver *, struct tty_struct *);\n",
                "serial_ioctl": "extern int ldv_emg_wrapper_serial_ioctl_13(struct tty_struct *, unsigned int, long unsigned int);\n",
                "serial_open": "extern int ldv_emg_wrapper_serial_open_15(struct tty_struct *, struct file *);\n",
                "serial_port_activate": "extern int ldv_emg_wrapper_serial_port_activate_7(struct tty_port *, struct tty_struct *);\n",
                "serial_port_shutdown": "extern void ldv_emg_wrapper_serial_port_shutdown_12(struct tty_port *);\n",
                "serial_set_termios": "extern void ldv_emg_wrapper_serial_set_termios_18(struct tty_struct *, struct ktermios *);\n",
                "serial_throttle": "extern void ldv_emg_wrapper_serial_throttle_19(struct tty_struct *);\n",
                "serial_tiocmget": "extern int ldv_emg_wrapper_serial_tiocmget_2(struct tty_struct *);\n",
                "serial_tiocmset": "extern int ldv_emg_wrapper_serial_tiocmset_10(struct tty_struct *, unsigned int, unsigned int);\n",
                "serial_unthrottle": "extern void ldv_emg_wrapper_serial_unthrottle_20(struct tty_struct *);\n",
                "serial_wait_until_sent": "extern void ldv_emg_wrapper_serial_wait_until_sent_11(struct tty_struct *, int);\n",
                "serial_write": "extern int ldv_emg_wrapper_serial_write_9(struct tty_struct *, unsigned char *, int);\n",
                "serial_write_room": "extern int ldv_emg_wrapper_serial_write_room_6(struct tty_struct *);\n",
                "serial_proc_show": "extern int ldv_wrapper_serial_proc_show(struct seq_file *m, void *v);\n",
                "serial_proc_open": "extern int ldv_wrapper_serial_proc_open(struct inode *inode, struct file *file);\n"
              }
            },
            "definitions": {
              "drivers/usb/serial/usb-serial.c": {
                "serial_proc_show": [
                  "/* AUX_FUNC ldv_wrapper_serial_proc_show */\n",
                  "int ldv_wrapper_serial_proc_show(struct seq_file *m, void *v) {\n",
                  "\treturn serial_proc_show(m, v);\n",
                  "}\n",
                  "\n"
                ],
                "serial_proc_open": [
                  "/* AUX_FUNC ldv_wrapper_serial_proc_open */\n",
                  "int ldv_wrapper_serial_proc_open(struct inode *inode, struct file *file) {\n",
                  "\treturn serial_proc_open(inode, file);\n",
                  "}\n",
                  "\n"
                ],
                "serial_break": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_break_3 */\n",
                  "int ldv_emg_wrapper_serial_break_3(struct tty_struct *arg0, int arg1) {\n",
                  "\treturn serial_break(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_chars_in_buffer": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_chars_in_buffer_4 */\n",
                  "int ldv_emg_wrapper_serial_chars_in_buffer_4(struct tty_struct *arg0) {\n",
                  "\treturn serial_chars_in_buffer(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_cleanup": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_cleanup_17 */\n",
                  "void ldv_emg_wrapper_serial_cleanup_17(struct tty_struct *arg0) {\n",
                  "\t serial_cleanup(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_close": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_close_16 */\n",
                  "void ldv_emg_wrapper_serial_close_16(struct tty_struct *arg0, struct file *arg1) {\n",
                  "\t serial_close(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_get_icount": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_get_icount_5 */\n",
                  "int ldv_emg_wrapper_serial_get_icount_5(struct tty_struct *arg0, struct serial_icounter_struct *arg1) {\n",
                  "\treturn serial_get_icount(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_hangup": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_hangup_8 */\n",
                  "void ldv_emg_wrapper_serial_hangup_8(struct tty_struct *arg0) {\n",
                  "\t serial_hangup(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_install": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_install_14 */\n",
                  "int ldv_emg_wrapper_serial_install_14(struct tty_driver *arg0, struct tty_struct *arg1) {\n",
                  "\treturn serial_install(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_ioctl": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_ioctl_13 */\n",
                  "int ldv_emg_wrapper_serial_ioctl_13(struct tty_struct *arg0, unsigned int arg1, long unsigned int arg2) {\n",
                  "\treturn serial_ioctl(arg0, arg1, arg2);\n",
                  "}\n",
                  "\n"
                ],
                "serial_open": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_open_15 */\n",
                  "int ldv_emg_wrapper_serial_open_15(struct tty_struct *arg0, struct file *arg1) {\n",
                  "\treturn serial_open(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_port_activate": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_port_activate_7 */\n",
                  "int ldv_emg_wrapper_serial_port_activate_7(struct tty_port *arg0, struct tty_struct *arg1) {\n",
                  "\treturn serial_port_activate(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_port_shutdown": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_port_shutdown_12 */\n",
                  "void ldv_emg_wrapper_serial_port_shutdown_12(struct tty_port *arg0) {\n",
                  "\t serial_port_shutdown(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_set_termios": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_set_termios_18 */\n",
                  "void ldv_emg_wrapper_serial_set_termios_18(struct tty_struct *arg0, struct ktermios *arg1) {\n",
                  "\t serial_set_termios(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_throttle": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_throttle_19 */\n",
                  "void ldv_emg_wrapper_serial_throttle_19(struct tty_struct *arg0) {\n",
                  "\t serial_throttle(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_tiocmget": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_tiocmget_2 */\n",
                  "int ldv_emg_wrapper_serial_tiocmget_2(struct tty_struct *arg0) {\n",
                  "\treturn serial_tiocmget(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_tiocmset": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_tiocmset_10 */\n",
                  "int ldv_emg_wrapper_serial_tiocmset_10(struct tty_struct *arg0, unsigned int arg1, unsigned int arg2) {\n",
                  "\treturn serial_tiocmset(arg0, arg1, arg2);\n",
                  "}\n",
                  "\n"
                ],
                "serial_unthrottle": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_unthrottle_20 */\n",
                  "void ldv_emg_wrapper_serial_unthrottle_20(struct tty_struct *arg0) {\n",
                  "\t serial_unthrottle(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "serial_wait_until_sent": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_wait_until_sent_11 */\n",
                  "void ldv_emg_wrapper_serial_wait_until_sent_11(struct tty_struct *arg0, int arg1) {\n",
                  "\t serial_wait_until_sent(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ],
                "serial_write": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_write_9 */\n",
                  "int ldv_emg_wrapper_serial_write_9(struct tty_struct *arg0, unsigned char *arg1, int arg2) {\n",
                  "\treturn serial_write(arg0, arg1, arg2);\n",
                  "}\n",
                  "\n"
                ],
                "serial_write_room": [
                  "/* AUX_FUNC ldv_emg_wrapper_serial_write_room_6 */\n",
                  "int ldv_emg_wrapper_serial_write_room_6(struct tty_struct *arg0) {\n",
                  "\treturn serial_write_room(arg0);\n",
                  "}\n",
                  "\n"
                ]
              }
            },
            "headers": [
              "linux/tty.h",
              "linux/tty_driver.h",
              "linux/fs.h"
            ],
            "identifier": "tty/tty_scenario/serial_ops",
            "labels": {
              "inode": {
                "declaration": "struct inode *inode"
              },
              "file": {
                "declaration": "struct file *file"
              },
              "ldv_param_0_10": {
                "declaration": "struct tty_port *ldv_param_0_10"
              },
              "ldv_param_0_4": {
                "declaration": "struct tty_port *ldv_param_0_4"
              },
              "ldv_param_1_11": {
                "declaration": "unsigned int ldv_param_1_11"
              },
              "ldv_param_1_13": {
                "declaration": "struct inode *ldv_param_1_13"
              },
              "ldv_param_1_15": {
                "declaration": "struct file *ldv_param_1_15"
              },
              "ldv_param_1_16": {
                "declaration": "struct ktermios *ldv_param_1_16"
              },
              "ldv_param_1_17": {
                "declaration": "struct termiox *ldv_param_1_17"
              },
              "ldv_param_1_3": {
                "declaration": "struct serial_icounter_struct *ldv_param_1_3"
              },
              "ldv_param_1_5": {
                "declaration": "unsigned char *ldv_param_1_5"
              },
              "ldv_param_1_7": {
                "declaration": "unsigned int ldv_param_1_7"
              },
              "ldv_param_1_9": {
                "declaration": "int ldv_param_1_9"
              },
              "ldv_param_2_12": {
                "declaration": "long unsigned int ldv_param_2_12"
              },
              "ldv_param_2_14": {
                "declaration": "int ldv_param_2_14"
              },
              "ldv_param_2_6": {
                "declaration": "int ldv_param_2_6"
              },
              "ldv_param_2_8": {
                "declaration": "unsigned int ldv_param_2_8"
              },
              "ret": {
                "declaration": "int ret",
                "value": "1"
              },
              "tty_driver": {
                "declaration": "struct tty_driver *tty_driver",
                "value": "usb_serial_tty_driver"
              },
              "tty_operations": {
                "declaration": "struct tty_operations *tty_operations",
                "value": "ldv_emg_alias_serial_ops_2"
              },
              "tty_struct": {
                "declaration": "struct tty_struct *tty_struct"
              }
            },
            "process": "(!tty_register).<init>.{main}"
          },
          "usb/usb_scenario_usb_serial_driver": {
            "reference": true,
            "actions": {
              "alloc_interface": {
                "comment": "Allocate memory and initialize new USB interface.",
                "statements": [
                  "$ALLOC(%resource%);",
                  "$ALLOC(%usb_device%);",
                  "%resource%->dev.parent = & %usb_device%->dev;"
                ]
              },
              "callback_2": {
                "comment": "No callbacks implemented to call here",
                "statements": [
                  "/* Skip callback without implementations */"
                ]
              },
              "deregister": {
                "comment": "Finish {} callbacks invocations scenario.",
                "condition": [
                  "%container% == $ARG1",
                  "$ARG1 == emg_alias_usb_serial_driver"
                ],
                "parameters": [
                  "%container%"
                ],
                "peers": [
                  "functions models/usb_deregister"
                ]
              },
              "failed_probe": {
                "comment": "Association of driver-specific data with the USB interface has been failed.",
                "condition": [
                  "%probe_retval% != 0"
                ]
              },
              "free_interface": {
                "comment": "Free allocated memory for USB interface.",
                "statements": [
                  "$FREE(%resource%);",
                  "$FREE(%usb_device%);"
                ]
              },
              "manage_interface": {
                "comment": "Manage particular interface on a device.",
                "process": "<pre_call_3>.<probe_5>.<post_call_4>.(<probe_success>.[tty_register].(<usb_reset>.<pre_12>.<post_13> | <pre_call_7>.<suspend_9>.<post_call_8>.(<resume_10> | <reset_resume_11>) | <callback_2> | <skip>).[tty_deregister].<release_6> | <failed_probe>).{manage_interface[1]} | <free_interface>.(deregister)"
              },
              "tty_register": {
                "comment": "Register tty callbacks.",
                "condition": [],
                "parameters": [],
                "peers": [
                  "tty/tty_scenario_serial_ops"
                ]
              },
              "tty_deregister": {
                "comment": "Deregister tty callbacks.",
                "condition": [],
                "parameters": [],
                "peers": [
                  "tty/tty_scenario_serial_ops"
                ]
              },
              "post_13": {
                "comment": "Initialize device after reset. Invoke callback post from USB.",
                "trace relevant": true,
                "statements": [
                  "if (%container%->post_reset) {",
                  "\t/* LDV {\"call\": \"%container%->post_reset(%resource%);\", \"type\": \"CALLBACK\", \"comment\": \"post\"} */",
                  "\t%container%->post_reset(%resource%);",
                  "}"
                ]
              },
              "post_call_4": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_2%);"
                ]
              },
              "post_call_8": {
                "comment": "Free memory of adhoc callback parameters.",
                "statements": [
                  "$FREE(%ldv_param_1_3%);"
                ]
              },
              "pre_12": {
                "comment": "Prepare for resetting device. Invoke callback pre from USB.",
                "trace relevant": true,
                "statements": [
                  "if (%container%->pre_reset) {",
                  "\t/* LDV {\"call\": \"%container%->pre_reset(%resource%);\", \"type\": \"CALLBACK\", \"comment\": \"pre\"} */",
                  "\t%container%->pre_reset(%resource%);",
                  "}"
                ]
              },
              "pre_call_3": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_2%);"
                ]
              },
              "pre_call_7": {
                "comment": "Allocate memory for adhoc callback parameters.",
                "statements": [
                  "$UALLOC(%ldv_param_1_3%);"
                ]
              },
              "probe_5": {
                "comment": "Associate driver-specific data with the USB interface. Invoke callback probe from usb_driver.",
                "trace relevant": true,
                "statements": [
                  "/* Callback pre-call */",
                  "ldv_pre_probe();",
                  "/* LDV {\"call\": \"%probe_retval% = ldv_emg_wrapper_usb_serial_probe_2(%resource%, %ldv_param_1_2%);\", \"type\": \"CALLBACK\", \"comment\": \"probe\"} */",
                  "%probe_retval% = ldv_emg_wrapper_usb_serial_probe_2(%resource%, %ldv_param_1_2%);",
                  "/* Callback post-call */",
                  "%probe_retval% = ldv_post_probe(%probe_retval%);"
                ]
              },
              "probe_success": {
                "comment": "Check that interface has been probed successfully.",
                "condition": [
                  "%probe_retval% == 0"
                ]
              },
              "register": {
                "comment": "Begin USB callbacks invocation scenario.",
                "condition": [
                  "$ARG1 == emg_alias_usb_serial_driver"
                ],
                "parameters": [
                  "%container%"
                ],
                "peers": [
                  "functions models/usb_register_driver"
                ],
                "replicative": true
              },
              "release_6": {
                "comment": "USB interface is no more accessible. Invoke callback disconnect from usb_driver.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"ldv_emg_wrapper_usb_serial_disconnect_3(%resource%);\", \"type\": \"CALLBACK\", \"comment\": \"release\"} */",
                  "ldv_emg_wrapper_usb_serial_disconnect_3(%resource%);"
                ]
              },
              "reset_resume_11": {
                "comment": "Device is about to be resumed. Invoke callback reset_resume from USB.",
                "trace relevant": true,
                "statements": [
                  "if (%container%->reset_resume) {",
                  "\t/* LDV {\"call\": \"%container%->reset_resume(%resource%);\", \"type\": \"CALLBACK\", \"comment\": \"reset_resume\"} */",
                  "\t%container%->reset_resume(%resource%);",
                  "}"
                ]
              },
              "resume_10": {
                "comment": "Device is about to be resumed. Invoke callback resume from usb_driver.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_resume(%resource%);\", \"type\": \"CALLBACK\", \"comment\": \"resume\"} */",
                  "usb_serial_resume(%resource%);"
                ]
              },
              "skip": {
                "comment": "Do not suspend or reset device."
              },
              "suspend_9": {
                "comment": "Device is about to be suspended. Invoke callback suspend from usb_driver.",
                "trace relevant": true,
                "statements": [
                  "/* LDV {\"call\": \"usb_serial_suspend(%resource%, *%ldv_param_1_3%);\", \"type\": \"CALLBACK\", \"comment\": \"suspend\"} */",
                  "usb_serial_suspend(%resource%, *%ldv_param_1_3%);"
                ]
              },
              "usb_reset": {
                "comment": "Stub instead of the 'usb_reset' signal.",
                "statements": [
                  "/* Skip signal 'usb_reset' as it has no peers */"
                ]
              }
            },
            "category": "usb",
            "comment": "Invoke usb callbacks. (Relevant to 'usb_serial_driver')",
            "declarations": {
              "environment model": {
                "& usb_serial_resume": "extern int usb_serial_resume(struct usb_interface *intf);\n",
                "& usb_serial_suspend": "extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);\n",
                "usb_serial_disconnect": "extern void ldv_emg_wrapper_usb_serial_disconnect_3(struct usb_interface *);\n",
                "usb_serial_probe": "extern int ldv_emg_wrapper_usb_serial_probe_2(struct usb_interface *, struct usb_device_id *);\n"
              }
            },
            "definitions": {
              "drivers/usb/serial/usb-serial.c": {
                "usb_serial_disconnect": [
                  "/* AUX_FUNC ldv_emg_wrapper_usb_serial_disconnect_3 */\n",
                  "void ldv_emg_wrapper_usb_serial_disconnect_3(struct usb_interface *arg0) {\n",
                  "\t usb_serial_disconnect(arg0);\n",
                  "}\n",
                  "\n"
                ],
                "usb_serial_probe": [
                  "/* AUX_FUNC ldv_emg_wrapper_usb_serial_probe_2 */\n",
                  "int ldv_emg_wrapper_usb_serial_probe_2(struct usb_interface *arg0, struct usb_device_id *arg1) {\n",
                  "\treturn usb_serial_probe(arg0, arg1);\n",
                  "}\n",
                  "\n"
                ]
              }
            },
            "headers": [
              "linux/usb.h"
            ],
            "identifier": "usb/usb_scenario/usb_serial_driver",
            "labels": {
              "container": {
                "declaration": "struct usb_driver *container",
                "value": "emg_alias_usb_serial_driver"
              },
              "ldv_param_1_2": {
                "declaration": "struct usb_device_id *ldv_param_1_2"
              },
              "ldv_param_1_3": {
                "declaration": "struct pm_message *ldv_param_1_3"
              },
              "probe_retval": {
                "declaration": "int probe_retval",
                "value": "ldv_undef_int()"
              },
              "resource": {
                "declaration": "struct usb_interface *resource"
              },
              "usb_device": {
                "declaration": "struct usb_device *usb_device"
              }
            },
            "process": "(!register).<alloc_interface>.{manage_interface}"
          }
        }
      }
    }
  ]
}