#!/usr/bin/env python3
#
# Copyright (c) 2018 ISP RAS (http://www.ispras.ru)
# Ivannikov Institute for System Programming of the Russian Academy of Sciences
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from distutils.dir_util import copy_tree
import hashlib
import os
import re
import shutil
import subprocess
import sys
import tarfile
import tempfile
import urllib.parse

from clade import Clade

sys.path.append(os.path.join(os.path.dirname(__file__), os.path.pardir))

from utils.utils import execute_cmd, get_logger, make_relative_path


preset_jobs_dir = os.path.join(os.path.dirname(__file__), os.path.pardir, os.path.pardir, 'bridge', 'jobs', 'presets')

common_target_program_descs = {
    'Linux': {
        'source code': 'linux-stable',
        'Git repository version': 'v3.14',
        'configuration': 'allmodconfig',
        'architecture': 'x86_64',
        'model CC options file': 'scripts/mod/empty.c',
        'external modules header files search directory': os.path.join(preset_jobs_dir, 'specifications'),
        'loadable kernel modules': ['all'],
        'allow local source trees use': True,
        'generate makefiles': True,
        'extra headers': [
            'linux/user_namespace.h',
            'linux/tty.h',
            'linux/tty_driver.h',
            'linux/usb.h',
            'linux/usb/serial.h',
            'linux/platform_device.h',
            'linux/netdevice.h',
            'linux/net.h',
            'linux/timer.h',
            'linux/interrupt.h',
            'linux/seq_file.h',
            'linux/i2c.h',
            'linux/mod_devicetable.h',
            'linux/device.h',
            'linux/pm.h',
            'linux/fs.h',
            'linux/rtnetlink.h',
            'net/mac80211.h',
            'linux/iio/iio.h',
            'linux/iio/triggered_buffer.h',
            'linux/cdev.h',
            'linux/miscdevice.h',
            'linux/pci.h',
            'linux/rtc.h',
            'scsi/scsi_host.h',
            'linux/pagemap.h',
            'linux/poll.h',
            'linux/blkdev.h',
            'target/target_core_base.h',
            'target/target_core_backend.h',
            'linux/spi/spi.h',
            'linux/fb.h'
        ],
        'extra Clade options': {'Info.extra_CIF_opts': [
            '-D__GNUC__=4',
            '-D__GNUC_MINOR__=6'
        ]}
    }
}

target_program_descs = [
    # # Testing on loadable Linux kernel modules.
    # {
    #     'build base': 'build bases/linux-3.14.79',
    #     'name': 'Linux',
    #     'Git repository version': 'v3.14.79',
    #     'loadable kernel modules': [
    #         'drivers/ata/pata_arasan_cf.ko',
    #         'drivers/idle/i7300_idle.ko',
    #         'drivers/uwb/hwa-rc.ko'
    #     ]
    # },
    # # Testing on artificial loadable Linux kernel modules.
    # {
    #     'build base': 'build bases/testing/5b3d50',
    #     'name': 'Linux',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'decomposition strategies', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/kernel_library',
    #         'ext-modules/load_order',
    #         'ext-modules/multimodule_error',
    #         'ext-modules/multimodule_false_error',
    #         'ext-modules/several_groups'
    #     ]
    # }
    # {
    #     'build base': 'build bases/testing/6e6e1c',
    #     'name': 'Linux',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'common models', 'tests'),
    #     'loadable kernel modules': [
    #         "ext-modules/linux/drivers/base/dd",
    #         "ext-modules/linux/drivers/spi",
    #         "ext-modules/linux/err",
    #         "ext-modules/linux/ldv/common",
    #         "ext-modules/linux/mm/gfp",
    #         "ext-modules/linux/mm/slab",
    #         "ext-modules/verifier/common",
    #         "ext-modules/verifier/gcc",
    #         "ext-modules/verifier/map",
    #         "ext-modules/verifier/memory",
    #         "ext-modules/verifier/nondet",
    #         "ext-modules/verifier/set/counter",
    #         "ext-modules/verifier/set/flag",
    #         "ext-modules/verifier/set/nonnegative-counter",
    #         "ext-modules/verifier/thread"
    #     ]
    # },
    # {
    #     'build base': 'build bases/testing/455c6f',
    #     'name': 'Linux',
    #     'Git repository version': 'v2.6.33.20',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'environment model specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/block_device_operations_v.1',
    #         'ext-modules/class_v.1',
    #         'ext-modules/devm_threaded_irq_v.1',
    #         'ext-modules/ethtool_ops_v.1',
    #         'ext-modules/file_operations_v.1',
    #         'ext-modules/get_sb_v.1',
    #         'ext-modules/hid_v.1',
    #         'ext-modules/ieee80211_ops_v.1',
    #         'ext-modules/irq_v.1',
    #         'ext-modules/kthread_v.1',
    #         'ext-modules/net_device_ops_v.1',
    #         'ext-modules/pci_driver_v.1',
    #         'ext-modules/platform_driver_v.1',
    #         'ext-modules/proto_v.1',
    #         'ext-modules/rtc_class_ops_v.1',
    #         'ext-modules/scsi_host_template_v.1',
    #         'ext-modules/seq_operations_v.1',
    #         'ext-modules/serial_core_v.1',
    #         'ext-modules/super_block_v.1',
    #         'ext-modules/tasklet_v.1',
    #         'ext-modules/timer_v.1',
    #         'ext-modules/tty_v.1',
    #         'ext-modules/urb_v.1',
    #         'ext-modules/usb_driver_v.1',
    #         'ext-modules/usb_serial_driver_v.1',
    #         'ext-modules/workqueue_v.1'
    #     ],
    #     'exclude extra headers': [
    #         'linux/iio/iio.h',
    #         'linux/iio/triggered_buffer.h',
    #         'target/target_core_base.h',
    #         'target/target_core_backend.h'
    #     ]
    # },
    # {
    #     'build base': 'build bases/testing/fedc1e',
    #     'name': 'Linux',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'environment model specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/block_device_operations_v.1',
    #         'ext-modules/class_v.1',
    #         'ext-modules/devm_threaded_irq_v.1',
    #         'ext-modules/ethtool_ops_v.1',
    #         'ext-modules/file_operations_v.1',
    #         'ext-modules/hid_v.1',
    #         'ext-modules/ieee80211_ops_v.1',
    #         'ext-modules/iio_triggered_buffer_v.1',
    #         'ext-modules/irq_v.2',
    #         'ext-modules/kthread_v.1',
    #         'ext-modules/net_device_ops_v.1',
    #         'ext-modules/pci_driver_v.1',
    #         'ext-modules/percpu_irq_v.1',
    #         'ext-modules/platform_driver_v.1',
    #         'ext-modules/proto_v.1',
    #         'ext-modules/rtc_class_ops_v.1',
    #         'ext-modules/scsi_host_template_v.1',
    #         'ext-modules/se_subsystem_api_v.1',
    #         'ext-modules/seq_operations_v.1',
    #         'ext-modules/serial_core_v.1',
    #         'ext-modules/tasklet_v.1',
    #         'ext-modules/timer_v.1',
    #         'ext-modules/tty_v.2',
    #         'ext-modules/urb_v.1',
    #         'ext-modules/usb_driver_v.1',
    #         'ext-modules/usb_serial_driver_v.2',
    #         'ext-modules/workqueue_v.1'
    #     ]
    # },
    # {
    #     'build base': 'build bases/testing/01358e',
    #     'name': 'Linux',
    #     'Git repository version': 'v4.6.7',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'environment model specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/block_device_operations_v.1',
    #         'ext-modules/class_v.1',
    #         'ext-modules/devm_threaded_irq_v.1',
    #         'ext-modules/ethtool_ops_v.2',
    #         'ext-modules/file_operations_v.1',
    #         'ext-modules/hid_v.1',
    #         'ext-modules/ieee80211_ops_v.1',
    #         'ext-modules/iio_triggered_buffer_v.1',
    #         'ext-modules/irq_v.2',
    #         'ext-modules/kthread_v.1',
    #         'ext-modules/net_device_ops_v.2',
    #         'ext-modules/pci_driver_v.1',
    #         'ext-modules/percpu_irq_v.1',
    #         'ext-modules/platform_driver_v.1',
    #         'ext-modules/proto_v.2',
    #         'ext-modules/rtc_class_ops_v.1',
    #         'ext-modules/scsi_host_template_v.1',
    #         'ext-modules/seq_operations_v.1',
    #         'ext-modules/serial_core_v.1',
    #         'ext-modules/target_backend_v.1',
    #         'ext-modules/tasklet_v.1',
    #         'ext-modules/timer_v.2',
    #         'ext-modules/tty_v.2',
    #         'ext-modules/urb_v.1',
    #         'ext-modules/usb_driver_v.1',
    #         'ext-modules/usb_serial_driver_v.2',
    #         'ext-modules/workqueue_v.1'
    #     ],
    #     'exclude extra headers': ['linux/poll.h'],
    #     # Linux 4.6.7 can be built with new versions of GCC.
    #     'extra Clade options': {}
    # },
    # {
    #     'build base': 'build bases/testing/1de383',
    #     'name': 'Linux',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'rule specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/linux/alloc/irq',
    #         'ext-modules/linux/alloc/spinlock',
    #         'ext-modules/linux/alloc/usb-lock',
    #         'ext-modules/linux/arch/io',
    #         'ext-modules/linux/block/genhd',
    #         'ext-modules/linux/block/queue',
    #         'ext-modules/linux/block/request',
    #         'ext-modules/linux/concurrency-safety/lock-reduce',
    #         'ext-modules/linux/concurrency-safety/simple',
    #         'ext-modules/linux/concurrency-safety/unsorted',
    #         'ext-modules/linux/drivers/base/class',
    #         'ext-modules/linux/drivers/base/dma-mapping',
    #         'ext-modules/linux/drivers/clk1',
    #         'ext-modules/linux/drivers/clk2',
    #         'ext-modules/linux/empty',
    #         'ext-modules/linux/fs/sysfs',
    #         'ext-modules/linux/kernel/locking/mutex',
    #         'ext-modules/linux/kernel/locking/rwlock',
    #         'ext-modules/linux/kernel/locking/spinlock',
    #         'ext-modules/linux/kernel/module',
    #         'ext-modules/linux/kernel/rcu/srcu',
    #         'ext-modules/linux/kernel/rcu/update/lock',
    #         'ext-modules/linux/kernel/rcu/update/lock-bh',
    #         'ext-modules/linux/kernel/rcu/update/lock-sched',
    #         'ext-modules/linux/kernel/sched/completion',
    #         'ext-modules/linux/lib/find_bit',
    #         'ext-modules/linux/lib/idr',
    #         'ext-modules/linux/memory-safety',
    #         'ext-modules/linux/net/register',
    #         'ext-modules/linux/net/rtnetlink',
    #         'ext-modules/linux/net/sock',
    #         'ext-modules/linux/usb/coherent',
    #         'ext-modules/linux/usb/dev',
    #         'ext-modules/linux/usb/gadget',
    #         'ext-modules/linux/usb/register',
    #         'ext-modules/linux/usb/urb'
    #     ]
    # },
    # {
    #     'build base': 'build bases/testing/1cae6b',
    #     'name': 'Linux',
    #     'configuration': os.path.join(preset_jobs_dir, 'linux', 'testing', 'rule specs', 'configs', 'no-lockdep'),
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'rule specs', 'tests'),
    #     # The only module needs specific kernel configuration for testing.
    #     'loadable kernel modules': ['ext-modules/linux/kernel/sched/completion-no-lockdep']
    # },
    # {
    #     'build base': 'build bases/testing/606cdb',
    #     'name': 'Linux',
    #     'external modules': os.path.join(preset_jobs_dir, 'testing verifiers', 'tests'),
    #     'loadable kernel modules': [
    #         "ext-modules/arrays/one-element",
    #         "ext-modules/arrays/ten-elements",
    #         "ext-modules/arrays/two-dimensional",
    #         "ext-modules/arrays/two-elements",
    #         "ext-modules/bitfields",
    #         "ext-modules/bitwise-operations/and",
    #         "ext-modules/bitwise-operations/complement",
    #         "ext-modules/bitwise-operations/left-shift",
    #         "ext-modules/bitwise-operations/or",
    #         "ext-modules/bitwise-operations/right-shift",
    #         "ext-modules/bitwise-operations/xor",
    #         "ext-modules/casts",
    #         "ext-modules/conditions/dangling-else",
    #         "ext-modules/conditions/if",
    #         "ext-modules/conditions/if-else",
    #         "ext-modules/conditions/if-else-if",
    #         "ext-modules/conditions/if-else-if-else",
    #         "ext-modules/conditions/nested",
    #         "ext-modules/conditions/ternary-operator",
    #         "ext-modules/dynamic-memory/xmalloc",
    #         "ext-modules/dynamic-memory/xmalloc-data",
    #         "ext-modules/dynamic-memory/xzalloc",
    #         "ext-modules/enumerations",
    #         "ext-modules/function-pointers",
    #         "ext-modules/gotos",
    #         "ext-modules/inline-assembler",
    #         "ext-modules/integers/binary-minus",
    #         "ext-modules/integers/binary-plus",
    #         "ext-modules/integers/division",
    #         "ext-modules/integers/multiplication",
    #         "ext-modules/integers/remainder",
    #         "ext-modules/integers/unary-minus",
    #         "ext-modules/integers/unary-plus",
    #         "ext-modules/inter-functional-analysis/one-level",
    #         "ext-modules/inter-functional-analysis/ten-levels",
    #         "ext-modules/inter-functional-analysis/two-levels",
    #         "ext-modules/lists",
    #         "ext-modules/logical-operations/and",
    #         "ext-modules/logical-operations/not",
    #         "ext-modules/logical-operations/or",
    #         "ext-modules/loops/break",
    #         "ext-modules/loops/continue",
    #         "ext-modules/loops/do-while",
    #         "ext-modules/loops/nested",
    #         "ext-modules/loops/one-iteration",
    #         "ext-modules/loops/ten-iterations",
    #         "ext-modules/loops/two-iterations",
    #         "ext-modules/loops/while",
    #         "ext-modules/pointers/address",
    #         "ext-modules/pointers/alias",
    #         "ext-modules/pointers/container-of",
    #         "ext-modules/pointers/dereference",
    #         "ext-modules/pointers/null",
    #         "ext-modules/recursion/one-depth",
    #         "ext-modules/recursion/ten-depth",
    #         "ext-modules/recursion/two-depth",
    #         "ext-modules/relational-operations/equal",
    #         "ext-modules/relational-operations/greater",
    #         "ext-modules/relational-operations/greater-or-equal",
    #         "ext-modules/relational-operations/less",
    #         "ext-modules/relational-operations/less-or-equal",
    #         "ext-modules/relational-operations/not-equal",
    #         "ext-modules/sizeof",
    #         "ext-modules/structures/no-nesting",
    #         "ext-modules/structures/one-nesting",
    #         "ext-modules/structures/ten-nesting",
    #         "ext-modules/switches/break",
    #         "ext-modules/switches/default",
    #         "ext-modules/switches/one-case",
    #         "ext-modules/switches/ten-cases",
    #         "ext-modules/switches/two-cases",
    #         "ext-modules/unions/no-nesting",
    #         "ext-modules/unions/one-nesting",
    #         "ext-modules/unions/same-memory",
    #         "ext-modules/unions/ten-nesting",
    #         "ext-modules/variables/assignment",
    #         "ext-modules/variables/bitwise-and-assignment",
    #         "ext-modules/variables/bitwise-or-assignment",
    #         "ext-modules/variables/bitwise-xor-assignment",
    #         "ext-modules/variables/division-assignment",
    #         "ext-modules/variables/left-shift-assignment",
    #         "ext-modules/variables/minus-assignment",
    #         "ext-modules/variables/multiplication-assignment",
    #         "ext-modules/variables/plus-assignment",
    #         "ext-modules/variables/postfix-decrement",
    #         "ext-modules/variables/postfix-increment",
    #         "ext-modules/variables/prefix-decrement",
    #         "ext-modules/variables/prefix-increment",
    #         "ext-modules/variables/remainder-assignment",
    #         "ext-modules/variables/right-shift-assignment"
    #     ]
    # }
    # # Validation on commits in Linux kernel Git repositories.
    # {
    #     'build base': 'build bases/validation/7ce77510c9c7~',
    #     'name': 'Linux',
    #     'Git repository version': '7ce77510c9c7~',
    #     'loadable kernel modules': ['drivers/usb/serial/opticon.ko'],
    #     'exclude extra headers': [
    #         'linux/iio/iio.h',
    #         'linux/iio/triggered_buffer.h',
    #         'target/target_core_backend.h'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/7ce77510c9c7',
    #     'name': 'Linux',
    #     'Git repository version': '7ce77510c9c7',
    #     'loadable kernel modules': ['drivers/usb/serial/opticon.ko'],
    #     'exclude extra headers': [
    #         'linux/iio/iio.h',
    #         'linux/iio/triggered_buffer.h',
    #         'target/target_core_backend.h'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/60b35930067d~',
    #     'name': 'Linux',
    #     'Git repository version': '60b35930067d~',
    #     'loadable kernel modules': ['drivers/media/usb/dvb-usb/dvb-usb-cxusb.ko']
    # },
    # {
    #     'build base': 'build bases/validation/60b35930067d',
    #     'name': 'Linux',
    #     'Git repository version': '60b35930067d',
    #     'loadable kernel modules': ['drivers/media/usb/dvb-usb/dvb-usb-cxusb.ko']
    # },
    # {
    #     'build base': 'build bases/validation/214c97a12f1f',
    #     'name': 'Linux',
    #     'Git repository version': '214c97a12f1f',
    #     'loadable kernel modules': ['drivers/media/usb/usbvision/usbvision.ko']
    # },
    # {
    #     'build base': 'build bases/validation/214c97a12f1f~',
    #     'name': 'Linux',
    #     'Git repository version': '214c97a12f1f~',
    #     'loadable kernel modules': ['drivers/media/usb/usbvision/usbvision.ko']
    # },
    # {
    #     'build base': 'build bases/validation/e4c7f259c5be~',
    #     'name': 'Linux',
    #     'Git repository version': 'e4c7f259c5be~',
    #     'loadable kernel modules': ['drivers/net/usb/kaweth.ko'],
    #     'exclude extra headers': ['linux/iio/triggered_buffer.h']
    # },
    # {
    #     'build base': 'build bases/validation/e4c7f259c5be',
    #     'name': 'Linux',
    #     'Git repository version': 'e4c7f259c5be',
    #     'loadable kernel modules': ['drivers/net/usb/kaweth.ko'],
    #     'exclude extra headers': ['linux/iio/triggered_buffer.h']
    # },
    # {
    #     'build base': 'build bases/validation/448356262f56~',
    #     'name': 'Linux',
    #     'Git repository version': '448356262f56~',
    #     'loadable kernel modules': ['drivers/usb/serial/kobil_sct.ko']
    # },
    # {
    #     'build base': 'build bases/validation/448356262f56',
    #     'name': 'Linux',
    #     'Git repository version': '448356262f56',
    #     'loadable kernel modules': ['drivers/usb/serial/kobil_sct.ko']
    # },
    # {
    #     'build base': 'build bases/validation/d8e172f3c0a5',
    #     'name': 'Linux',
    #     'Git repository version': 'd8e172f3c0a5',
    #     'loadable kernel modules': ['drivers/spi/spi-imx.ko']
    # },
    # {
    #     'build base': 'build bases/validation/d8e172f3c0a5~',
    #     'name': 'Linux',
    #     'Git repository version': 'd8e172f3c0a5~',
    #     'loadable kernel modules': ['drivers/spi/spi-imx.ko']
    # },
    # {
    #     'build base': 'build bases/validation/bff71889260f~',
    #     'name': 'Linux',
    #     'Git repository version': 'bff71889260f~',
    #     'loadable kernel modules': ['drivers/staging/iio/adc/mxs-lradc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/bff71889260f',
    #     'name': 'Linux',
    #     'Git repository version': 'bff71889260f',
    #     'loadable kernel modules': ['drivers/staging/iio/adc/mxs-lradc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/2ba4b92e8773~',
    #     'name': 'Linux',
    #     'Git repository version': '2ba4b92e8773~',
    #     'loadable kernel modules': ['drivers/usb/dwc2/dwc2_gadget.ko']
    # },
    # {
    #     'build base': 'build bases/validation/2ba4b92e8773',
    #     'name': 'Linux',
    #     'Git repository version': '2ba4b92e8773',
    #     'loadable kernel modules': ['drivers/usb/dwc2/dwc2_gadget.ko']
    # },
    # {
    #     'build base': 'build bases/validation/c822fb57ba12~',
    #     'name': 'Linux',
    #     'Git repository version': 'c822fb57ba12~',
    #     'loadable kernel modules': ['drivers/spi/spi-pxa2xx-platform.ko']
    # },
    # {
    #     'build base': 'build bases/validation/c822fb57ba12',
    #     'name': 'Linux',
    #     'Git repository version': 'c822fb57ba12',
    #     'loadable kernel modules': ['drivers/spi/spi-pxa2xx-platform.ko']
    # },
    # {
    #     'build base': 'build bases/validation/5c256d215753~',
    #     'name': 'Linux',
    #     'Git repository version': '5c256d215753~',
    #     'loadable kernel modules': ['drivers/media/usb/dvb-usb/dvb-usb-dw2102.ko']
    # },
    # {
    #     'build base': 'build bases/validation/5c256d215753',
    #     'name': 'Linux',
    #     'Git repository version': '5c256d215753',
    #     'loadable kernel modules': ['drivers/media/usb/dvb-usb/dvb-usb-dw2102.ko']
    # },
    # {
    #     'build base': 'build bases/validation/790cc82a2b2b~',
    #     'name': 'Linux',
    #     'Git repository version': '790cc82a2b2b~',
    #     'loadable kernel modules': ['drivers/input/misc/arizona-haptics.ko']
    # },
    # {
    #     'build base': 'build bases/validation/790cc82a2b2b',
    #     'name': 'Linux',
    #     'Git repository version': '790cc82a2b2b',
    #     'loadable kernel modules': ['drivers/input/misc/arizona-haptics.ko']
    # },
    # {
    #     'build base': 'build bases/validation/ae3f34854485~',
    #     'name': 'Linux',
    #     'Git repository version': 'ae3f34854485~',
    #     'loadable kernel modules': ['fs/nfs/nfs.ko']
    # },
    # {
    #     'build base': 'build bases/validation/ae3f34854485',
    #     'name': 'Linux',
    #     'Git repository version': 'ae3f34854485',
    #     'loadable kernel modules': ['fs/nfs/nfs.ko']
    # },
    # {
    #     'build base': 'build bases/validation/44f694330e1e~',
    #     'name': 'Linux',
    #     'Git repository version': '44f694330e1e~',
    #     'loadable kernel modules': ['net/sunrpc/sunrpc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/44f694330e1e',
    #     'name': 'Linux',
    #     'Git repository version': '44f694330e1e',
    #     'loadable kernel modules': ['net/sunrpc/sunrpc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/21a018a58f3c~',
    #     'name': 'Linux',
    #     'Git repository version': '21a018a58f3c~',
    #     'loadable kernel modules': ['net/tipc/tipc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/21a018a58f3c',
    #     'name': 'Linux',
    #     'Git repository version': '21a018a58f3c',
    #     'loadable kernel modules': ['net/tipc/tipc.ko']
    # },
    # {
    #     'build base': 'build bases/validation/ac4de081312a~',
    #     'name': 'Linux',
    #     'Git repository version': 'ac4de081312a~',
    #     'loadable kernel modules': [
    #         'drivers/leds/leds-lp55xx-common.ko',
    #         'drivers/leds/leds-lp5523.ko',
    #         'drivers/leds/leds-lp5521.ko'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/ac4de081312a',
    #     'name': 'Linux',
    #     'Git repository version': 'ac4de081312a',
    #     'loadable kernel modules': [
    #         'drivers/leds/leds-lp55xx-common.ko',
    #         'drivers/leds/leds-lp5523.ko',
    #         'drivers/leds/leds-lp5521.ko'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/063579d4c3ed~',
    #     'name': 'Linux',
    #     'Git repository version': '063579d4c3ed~',
    #     'loadable kernel modules': [
    #         'drivers/w1/wire.ko',
    #         'drivers/w1/masters/ds2482.ko'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/063579d4c3ed',
    #     'name': 'Linux',
    #     'Git repository version': '063579d4c3ed',
    #     'loadable kernel modules': [
    #         'drivers/w1/wire.ko',
    #         'drivers/w1/masters/ds2482.ko'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/9aaf9678ea3e~',
    #     'name': 'Linux',
    #     'Git repository version': '9aaf9678ea3e~',
    #     'loadable kernel modules': [
    #         'sound/pci/emu10k1/snd-emu10k1.ko',
    #         'sound/pci/emu10k1/snd-emu10k1-synth.ko'
    #     ],
    #     'exclude extra headers': [
    #         'linux/iio/iio.h',
    #         'linux/iio/triggered_buffer.h',
    #         'target/target_core_backend.h'
    #     ]
    # },
    # {
    #     'build base': 'build bases/validation/9aaf9678ea3e',
    #     'name': 'Linux',
    #     'Git repository version': '9aaf9678ea3e',
    #     'loadable kernel modules': [
    #         'sound/pci/emu10k1/snd-emu10k1.ko',
    #         'sound/pci/emu10k1/snd-emu10k1-synth.ko'
    #     ],
    #     'exclude extra headers': [
    #         'linux/iio/iio.h',
    #         'linux/iio/triggered_buffer.h',
    #         'target/target_core_backend.h'
    #     ]
    # }
]


# TODO: Unsupported tests.
unsupported_target_program_descs = [
    # {
    #     'build base': 'build bases/testing/57d7f5',
    #     'name': 'Linux',
    #     'Git repository version': 'v4.15.18',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'environment model specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/block_device_operations_v.1',
    #         'ext-modules/class_v.1',
    #         'ext-modules/devm_threaded_irq_v.1',
    #         'ext-modules/ethtool_ops_v.2',
    #         'ext-modules/file_operations_v.1',
    #         'ext-modules/hid_v.1',
    #         'ext-modules/ieee80211_ops_v.1',
    #         'ext-modules/iio_triggered_buffer_v.1',
    #         'ext-modules/irq_v.2',
    #         'ext-modules/net_device_ops_v.2',
    #         'ext-modules/pci_driver_v.1',
    #         'ext-modules/percpu_irq_v.1',
    #         'ext-modules/platform_driver_v.1',
    #         'ext-modules/proto_v.2',
    #         'ext-modules/rtc_class_ops_v.1',
    #         'ext-modules/scsi_host_template_v.1',
    #         'ext-modules/seq_operations_v.1',
    #         'ext-modules/serial_core_v.1',
    #         'ext-modules/target_backend_v.1',
    #         'ext-modules/tty_v.2',
    #         'ext-modules/usb_driver_v.1',
    #         'ext-modules/usb_serial_driver_v.2',
    #         'ext-modules/timer_v.3',
    #         'ext-modules/workqueue_v.1',
    #         'ext-modules/urb_v.1',
    #         'ext-modules/tasklet_v.2',
    #         'ext-modules/kthread_v.1'
    #     ],
    #     'exclude extra headers': ['linux/poll.h'],
    #     # Linux 4.15.18 can be built with new versions of GCC.
    #     'extra Clade options': {}
    # },
    # {
    #     'build base': 'build bases/testing/7a7e7e',
    #     'name': 'Linux',
    #     'Git repository version': 'v4.17.19',
    #     'external modules': os.path.join(preset_jobs_dir, 'linux', 'testing', 'environment model specs', 'tests'),
    #     'loadable kernel modules': [
    #         'ext-modules/block_device_operations_v.1',
    #         'ext-modules/class_v.1',
    #         'ext-modules/devm_threaded_irq_v.1',
    #         'ext-modules/ethtool_ops_v.2',
    #         'ext-modules/file_operations_v.1',
    #         'ext-modules/hid_v.1',
    #         'ext-modules/ieee80211_ops_v.1',
    #         'ext-modules/iio_triggered_buffer_v.1',
    #         'ext-modules/irq_v.2',
    #         'ext-modules/net_device_ops_v.2',
    #         'ext-modules/pci_driver_v.1',
    #         'ext-modules/percpu_irq_v.1',
    #         'ext-modules/platform_driver_v.1',
    #         'ext-modules/proto_v.2',
    #         'ext-modules/rtc_class_ops_v.1',
    #         'ext-modules/scsi_host_template_v.1',
    #         'ext-modules/seq_operations_v.1',
    #         'ext-modules/serial_core_v.1',
    #         'ext-modules/target_backend_v.1',
    #         'ext-modules/tty_v.2',
    #         'ext-modules/usb_driver_v.1',
    #         'ext-modules/usb_serial_driver_v.2',
    #         'ext-modules/timer_v.3',
    #         'ext-modules/workqueue_v.1',
    #         'ext-modules/urb_v.1',
    #         'ext-modules/tasklet_v.2',
    #         'ext-modules/kthread_v.1'
    #     ],
    #     'exclude extra headers': ['linux/poll.h'],
    #     # Linux v4.17.19 can be built with new versions of GCC.
    #     'extra Clade options': {}
    # }
]


class CProgram:
    _CLADE_CONF = dict()
    _CLADE_PRESET = "klever_linux_kernel"

    def __init__(self, logger, target_program_desc):
        self.logger = logger
        self.target_program_desc = target_program_desc

        # Main working source tree where various build and auxiliary actions will be performed.
        self.work_src_tree = None

        # TODO: make this adaptive.
        # The number of parallel jobs for make.
        self.jobs = '8'

        # C program attributes. We expect that architecture is always specified in target program description while
        # configuration and version can be either obtained during build somehow or remained unspecified.
        self.architecture = self.target_program_desc['architecture']
        self.configuration = None
        self.version = None

        # Working source trees are directories to be trimed from file names.
        self.work_src_trees = []
        # Temporary directories that should be removed at the end of work.
        self.tmp_dirs = []

    def _build(self):
        self.logger.info('Build C program')
        self._make(intercept_build_cmds=True)

    def _clean(self):
        self.logger.info('Clean working source tree')
        self._make('clean')

    def _configure(self):
        self.logger.info('Configure C program')
        execute_cmd(self.logger, './configure', cwd=self.work_src_tree)

    def _fetch_work_src_tree(self):
        src = self.target_program_desc['source code']
        self.work_src_tree = tempfile.mkdtemp()
        self.tmp_dirs.append(self.work_src_tree)

        self.logger.info('Fetch source code from "{0}" to working source tree "{1}"'.format(src, self.work_src_tree))

        o = urllib.parse.urlparse(src)
        if o[0] in ('http', 'https', 'ftp'):
            raise NotImplementedError('Source code is provided in unsupported form of remote archive')
        elif o[0] == 'git':
            raise NotImplementedError('Source code is provided in unsupported form of remote Git repository')
        elif o[0]:
            raise ValueError('Source code is provided in unsupported form "{0}"'.format(o[0]))

        if os.path.isdir(src):
            if self.target_program_desc['allow local source trees use']:
                self.logger.info('Use original source tree "{0}" rather than fetch it to working source tree "{1}"'
                                 .format(src, self.work_src_tree))
                self.work_src_tree = src
            else:
                shutil.copytree(src, self.work_src_tree, symlinks=True)

            if os.path.isdir(os.path.join(src, '.git')):
                self.logger.debug("Source code is provided in form of Git repository")
            else:
                self.logger.debug("Source code is provided in form of source tree")

            if 'Git repository version' in self.target_program_desc:
                self.logger.info('Checkout Git repository "{0}"'
                                 .format(self.target_program_desc['Git repository version']))

                # Always remove Git repository lock file .git/index.lock if it exists since it can remain after
                # some previous Git commands crashed.
                git_index_lock = os.path.join(self.work_src_tree, '.git', 'index.lock')
                if os.path.isfile(git_index_lock):
                    os.remove(git_index_lock)

                # In case of dirty Git working directory checkout may fail so clean up it first.
                execute_cmd(self.logger, 'git', 'clean', '-f', '-d', cwd=self.work_src_tree)
                execute_cmd(self.logger, 'git', 'reset', '--hard', cwd=self.work_src_tree)
                execute_cmd(self.logger, 'git', 'checkout', '-f', self.target_program_desc['Git repository version'],
                            cwd=self.work_src_tree)

                # Use Git describe to properly identify C program version which source code is provided in form of Git
                # repository.
                stdout = execute_cmd(self.logger, 'git', 'describe', cwd=self.work_src_tree, get_output=True)
                self.version = stdout[0]
        elif os.path.isfile(src):
            self.logger.debug('Source code is provided in form of archive')
            with tarfile.open(src, encoding='utf8') as TarFile:
                TarFile.extractall(self.work_src_tree)
        else:
            raise ValueError('Source code is not provided at "{0}"'.format(src))

        self.work_src_trees.append(os.path.realpath(self.work_src_tree))

    def _get_version(self):
        self.version = self.target_program_desc.get('version')

    def _make(self, *target, opts=None, env=None, intercept_build_cmds=False, get_output=False):
        if opts is None:
            opts = []

        # TODO: switch to Clade Python API.
        return execute_cmd(self.logger,
                           *((['clade', '-ia', '--cmds', os.path.realpath(os.path.join(self.work_src_tree, 'cmds.txt'))]
                              if intercept_build_cmds else []) + ['make', '-j', self.jobs] + opts + list(target)),
                           cwd=self.work_src_tree, env=env, get_output=get_output)

    def _make_canonical_work_src_tree(self):
        self.logger.info('Make canonical working source tree "{0}"'.format(self.work_src_tree))

        def _is_src_tree_root(fnames):
            for filename in fnames:
                if filename == 'Makefile':
                    return True

            return False

        work_src_tree_root = None
        for dirpath, _, filenames in os.walk(self.work_src_tree):
            if _is_src_tree_root(filenames):
                work_src_tree_root = dirpath
                break

        if not work_src_tree_root:
            raise ValueError('Could not find Makefile in working source tree "{0}"'.format(self.work_src_tree))

        if os.path.samefile(work_src_tree_root, self.work_src_tree):
            return

        self.logger.debug('Move contents of "{0}" to "{1}"'.format(work_src_tree_root, self.work_src_tree))
        for path in os.listdir(work_src_tree_root):
            shutil.move(os.path.join(work_src_tree_root, path), self.work_src_tree)
        trash_dir = work_src_tree_root
        while True:
            parent_dir = os.path.join(trash_dir, os.path.pardir)
            if os.path.samefile(parent_dir, self.work_src_tree):
                break
            trash_dir = parent_dir

        self.logger.debug('Remove "{0}"'.format(trash_dir))
        shutil.rmtree(os.path.realpath(trash_dir))

    def build(self):
        self._fetch_work_src_tree()
        self._make_canonical_work_src_tree()
        self._clean()
        self._get_version()

        if self.version:
            self.logger.info('C program version is "{0}"'.format(self.version))

        self._configure()

        if self.configuration:
            self.logger.info('C program configuration is "{0}"'.format(self.configuration))

        self._build()

        if os.path.isdir(self.target_program_desc['build base']):
            shutil.rmtree(self.target_program_desc['build base'])

        if 'extra Clade options' in self.target_program_desc:
            clade_conf = dict(self._CLADE_CONF)
            clade_conf.update(self.target_program_desc['extra Clade options'])
        else:
            clade_conf = self._CLADE_CONF

        clade = Clade(work_dir=self.target_program_desc['build base'],
                      cmds_file=os.path.join(self.work_src_tree, 'cmds.txt'),
                      conf=clade_conf,
                      preset=self._CLADE_PRESET)
        clade.parse_list(["CrossRef", "Callgraph", "Variables", "Typedefs", "Macros"])

        self.logger.info('Save project attributes, working source trees and target program description to build base')
        clade.add_meta_by_key('project attrs', [
            {
                'name': type(self).__name__,
                'value': [{'name': name, 'value': getattr(self, name)}
                          for name in ('architecture', 'version', 'configuration')]
            }
        ])
        clade.add_meta_by_key('working source trees', self.work_src_trees)
        clade.add_meta_by_key('target program description', self.target_program_desc)

        self.logger.info('Remove temporary directories')
        for tmp_dir in self.tmp_dirs:
            shutil.rmtree(tmp_dir)


class Linux(CProgram):
    _ARCH_OPTS = {
        'arm': {
            'ARCH': 'arm',
            'CROSS_COMPILE': 'arm-unknown-linux-gnueabi-'
        },
        'x86_64': {
            'ARCH': 'x86_64'
        }
    }
    _CLADE_CONF = dict()
    _CLADE_PRESET = 'linux_kernel'

    def __init__(self, logger, target_program_desc):
        super().__init__(logger, target_program_desc)
        self.kconfig_config = None

    def _build(self):
        self.logger.info('Build Linux kernel')

        # Build Linux kernel if necessary.
        if self.target_program_desc.get('build kernel'):
            self._make('vmlinux', intercept_build_cmds=True)

        # To build external Linux kernel modules we need to specify "M=path/to/ext/modules/dir".
        ext_modules = self.__prepare_ext_modules()

        try:
            # Try to prepare for building modules. This is necessary and should finish successfully when the Linux
            # kernel supports loadable modules.
            self._make('modules_prepare', intercept_build_cmds=True)
            support_loadable_kernel_modules = True
        except subprocess.CalledProcessError:
            # Otherwise the command above will most likely fail. In this case compile special file, namely,
            # scripts/mod/empty.o, that seems to exist in all Linux kernel versions and that will provide options for
            # building C files including headers necessary for models.
            self._make('scripts/mod/empty.o', intercept_build_cmds=True)
            support_loadable_kernel_modules = False

        def modules_make_target():
            # Use target "modules" when the Linux kernel supports loadable modules.
            if support_loadable_kernel_modules:
                return 'modules'
            # Otherwise build all builtin modules indirectly by using target "all".
            else:
                return 'all'

        if len(self.target_program_desc.get('loadable kernel modules', [])) > 0:
            self.logger.info('Build loadable kernel modules')

            # Specially process building of all modules.
            if 'all' in self.target_program_desc['loadable kernel modules']:
                if len(self.target_program_desc['loadable kernel modules']) != 1:
                    raise ValueError('Can not build all modules and something else')

                self._make(*((['M=' + os.path.join(ext_modules, 'ext-modules')] if ext_modules else []) +
                             [modules_make_target()]),
                           intercept_build_cmds=True)
            else:
                # Check that modules aren't intersect explicitly.
                for i, modules1 in enumerate(self.target_program_desc['loadable kernel modules']):
                    for j, modules2 in enumerate(self.target_program_desc['loadable kernel modules']):
                        if i != j:
                            if modules1 == modules2:
                                raise ValueError('Modules "{0}" are duplicated'.format(modules1))
                            else:
                                # Get rid of file names, remain just directories.
                                if not re.search(r'\.ko$', modules1) or not re.search(r'\.ko$', modules2):
                                    modules1_dir = os.path.dirname(modules1) \
                                        if re.search(r'\.ko$', modules1) else modules1
                                    modules2_dir = os.path.dirname(modules2) \
                                        if re.search(r'\.ko$', modules2) else modules2

                                    if modules1_dir != make_relative_path([modules2_dir], modules1_dir):
                                        raise ValueError('Modules "{0}" are subset of modules "{1}"'
                                                         .format(modules1, modules2))

                # Examine modules to get all build targets. Do not build immediately to catch mistakes earlier.
                build_targets = []
                for modules in self.target_program_desc['loadable kernel modules']:
                    # Modules ending with .ko imply individual modules.
                    if re.search(r'\.ko$', modules):
                        if ext_modules:
                            build_targets.append([os.path.join(ext_modules, modules)])
                        else:
                            build_targets.append([modules])
                    # Otherwise it is directory that can contain modules.
                    else:
                        if ext_modules:
                            if not os.path.isdir(os.path.join(ext_modules, modules)):
                                raise ValueError('There is no directory "{0}" inside "{1}"'
                                                 .format(modules, ext_modules))

                            build_target = 'M=' + os.path.join(ext_modules, modules)
                        else:
                            if not os.path.isdir(os.path.join(self.work_src_tree, modules)):
                                raise ValueError('There is no directory "{0}" inside "{1}"'.
                                                 format(modules, self.work_src_tree))

                            build_target = 'M=' + modules

                        build_targets.append([build_target, modules_make_target()])

                for build_target in build_targets:
                    self._make(*build_target, intercept_build_cmds=True)

        # Generate C file including extra headers and Makefile. Compile this C file. It will be treated as part of
        # kernel, so, one will need to filter them out later if required.
        if 'extra headers' in self.target_program_desc:
            tmp_dir = tempfile.mkdtemp()
            self.tmp_dirs.append(tmp_dir)

            with open(os.path.join(tmp_dir, 'extra-headers.c'), 'w', encoding='utf8') as fp:
                for header in self.target_program_desc['extra headers']:
                    if header not in self.target_program_desc.get('exclude extra headers', []):
                        fp.write('#include <{0}>\n'.format(header))

            with open(os.path.join(tmp_dir, 'Makefile'), 'w', encoding='utf-8') as fp:
                fp.write('obj-y += extra-headers.o\n')

            self._make('M=' + tmp_dir, intercept_build_cmds=True)

    def _clean(self):
        self._make('mrproper')

    def _configure(self):
        self.logger.info('Configure Linux kernel')

        # Linux kernel configuration can be specified by means of configuration file or configuration target.
        if os.path.isfile(self.target_program_desc['configuration']):
            conf_file = self.target_program_desc['configuration']

            self.logger.info('Linux kernel configuration file is "{0}"'.format(conf_file))

            # Use configuration file SHA1 digest as Linux kernel configuration.
            with open(conf_file, 'rb') as fp:
                self.configuration = hashlib.sha1(fp.read()).hexdigest()[:7]

            self.logger.info('Linux kernel configuration file SHA1 digest is "{0}"'.format(self.configuration))
            shutil.copy(conf_file, self.work_src_tree)
            self.kconfig_config = os.path.basename(conf_file)
            target = ['oldconfig', 'KCONFIG_CONFIG={0}'.format(self.kconfig_config)]
        else:
            self.logger.debug('Linux kernel configuration target is "{0}"'
                              .format(self.target_program_desc['configuration']))

            # Use configuration target as Linux kernel configuration.
            self.configuration = self.target_program_desc['configuration']

            target = [self.configuration]

        self._make(*target)

    def _get_version(self):
        self.logger.info('Get Linux kernel version')

        if not self.version:
            output = self._make('kernelversion', get_output=True)
            self.version = output[0]

    def _make(self, *target, **kwargs):
        kwargs['opts'] = ['{0}={1}'.format(name, value) for name, value in self._ARCH_OPTS[self.architecture].items()]
        if self.kconfig_config:
            kwargs['opts'].append('KCONFIG_CONFIG={0}'.format(self.kconfig_config))

        return super()._make(*target, **kwargs)

    def __prepare_ext_modules(self):
        ext_modules = self.target_program_desc.get('external modules')

        if not ext_modules:
            return None

        tmp_dir = tempfile.mkdtemp()
        self.tmp_dirs.append(tmp_dir)

        # Always put source code of external loadable Linux kernel modules into this magical directory as this will
        # allow to distinguish them at various stages later.
        work_src_tree = os.path.join(tmp_dir, 'ext-modules')
        # Parent directory of this magical directory will be trimmed from program fragment identifiers (absolute paths
        # to external loadable Linux kernel modules) and file names.
        self.work_src_trees.append(tmp_dir)

        self.logger.info(
            'Fetch source code of external loadable Linux kernel modules from "{0}" to working source tree "{1}"'
            .format(ext_modules, work_src_tree))

        if os.path.isdir(ext_modules):
            self.logger.debug('External loadable Linux kernel modules source code is provided in form of source tree')
            copy_tree(ext_modules, work_src_tree)
        elif os.path.isfile(ext_modules):
            self.logger.debug('External loadable Linux kernel modules source code is provided in form of archive')
            with tarfile.open(ext_modules, encoding='utf8') as TarFile:
                TarFile.extractall(work_src_tree)

        self.logger.info('Make canonical working source tree of external loadable Linux kernel modules')
        work_src_tree_root = None
        for dirpath, dirnames, filenames in os.walk(work_src_tree):
            ismakefile = False
            for filename in filenames:
                if filename == 'Makefile':
                    ismakefile = True
                    break

            # Generate Linux kernel module Makefiles recursively starting from source tree root directory if they do not
            # exist.
            if self.target_program_desc['generate makefiles']:
                if not work_src_tree_root:
                    work_src_tree_root = dirpath

                if not ismakefile:
                    with open(os.path.join(dirpath, 'Makefile'), 'w', encoding='utf-8') as fp:
                        fp.write('obj-m += $(patsubst %, %/, $(notdir $(patsubst %/, %, {0})))\n'
                                 .format('$(filter %/, $(wildcard $(src)/*/))'))
                        fp.write('obj-m += $(notdir $(patsubst %.c, %.o, $(wildcard $(src)/*.c)))\n')
                        # Specify additional directory to search for model headers.
                        fp.write('ccflags-y += -I' + os.path.realpath(
                            self.target_program_desc['external modules header files search directory']))
            elif ismakefile:
                work_src_tree_root = dirpath
                break

        if not work_src_tree_root:
            raise ValueError('Could not find Makefile in working source tree "{0}"'.format(work_src_tree))
        elif not os.path.samefile(work_src_tree_root, work_src_tree):
            self.logger.debug('Move contents of "{0}" to "{1}"'.format(work_src_tree_root, work_src_tree))
            for path in os.listdir(work_src_tree_root):
                shutil.move(os.path.join(work_src_tree_root, path), work_src_tree)
            trash_dir = work_src_tree_root
            while True:
                parent_dir = os.path.join(trash_dir, os.path.pardir)
                if os.path.samefile(parent_dir, work_src_tree):
                    break
                trash_dir = parent_dir
            self.logger.debug('Remove "{0}"'.format(trash_dir))
            shutil.rmtree(os.path.realpath(trash_dir))

        return tmp_dir


class BusyBox(CProgram):
    def __init__(self, logger, target_program_desc):
        super().__init__(logger, target_program_desc)


def klever_build():
    logger = get_logger(__name__)

    for target_program_desc in target_program_descs:
        logger.info('Prepare build base "{}"'.format(target_program_desc['build base']))
        common_target_program_desc = dict(common_target_program_descs[target_program_desc['name']])
        common_target_program_desc.update(target_program_desc)
        getattr(sys.modules[__name__], target_program_desc['name'])(logger, common_target_program_desc).build()
        logger.info('Build base "{}" was successfully prepared'.format(target_program_desc['build base']))


if __name__ == '__main__':
    klever_build()
